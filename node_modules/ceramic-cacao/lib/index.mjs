import apgApi from 'apg-js/src/apg-api/api.js';
import apgLib from 'apg-js/src/apg-lib/node-exports.js';
import { AccountId, ChainId } from 'caip';
import { verifyMessage } from '@ethersproject/wallet';
import * as dagCbor from '@ipld/dag-cbor';
import { verify } from '@stablelib/ed25519';
import * as Block from 'multiformats/block';
import { sha256 } from 'multiformats/hashes/sha2';
import { fromString } from 'uint8arrays/from-string';

const GRAMMAR = `
sign-in-with-ethereum =
    domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Chain ID: " chain-id LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Resources:"
    resources ]

domain = dnsauthority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = *( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 4501

dnsauthority    = host [ ":" port ]
                             ; See RFC 3986 for the
                             ; definition of "host" and "port".

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
class ParsedMessage {
  constructor(msg) {
    this.domain = void 0;
    this.address = void 0;
    this.statement = void 0;
    this.uri = void 0;
    this.version = void 0;
    this.nonce = void 0;
    this.issuedAt = void 0;
    this.expirationTime = void 0;
    this.notBefore = void 0;
    this.requestId = void 0;
    this.chainId = void 0;
    this.resources = void 0;
    const api = new apgApi(GRAMMAR);
    api.generate();

    if (api.errors.length) {
      console.error(api.errorsToAscii());
      console.error(api.linesToAscii());
      console.log(api.displayAttributeErrors());
      throw new Error(`ABNF grammar has errors`);
    }

    const grammarObj = api.toObject();
    const parser = new apgLib.parser();
    parser.ast = new apgLib.ast();
    const id = apgLib.ids;

    const domain = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.domain = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks.domain = domain;

    const address = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.address = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks.address = address;

    const statement = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.statement = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks.statement = statement;

    const uri = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        if (!data.uri) {
          data.uri = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
        }
      }

      return ret;
    };

    parser.ast.callbacks.uri = uri;

    const version = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.version = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks.version = version;

    const chainId = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.chainId = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks['chain-id'] = chainId;

    const nonce = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.nonce = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks.nonce = nonce;

    const issuedAt = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.issuedAt = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks['issued-at'] = issuedAt;

    const expirationTime = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.expirationTime = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks['expiration-time'] = expirationTime;

    const notBefore = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.notBefore = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks['not-before'] = notBefore;

    const requestId = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.requestId = apgLib.utils.charsToString(chars, phraseIndex, phraseLength);
      }

      return ret;
    };

    parser.ast.callbacks['request-id'] = requestId;

    const resources = function (state, chars, phraseIndex, phraseLength, data) {
      const ret = id.SEM_OK;

      if (state === id.SEM_PRE) {
        data.resources = apgLib.utils.charsToString(chars, phraseIndex, phraseLength).slice(3).split('\n- ');
      }

      return ret;
    };

    parser.ast.callbacks.resources = resources;
    const result = parser.parse(grammarObj, 'sign-in-with-ethereum', msg);

    if (!result.success) {
      throw new Error(`Invalid message: ${JSON.stringify(result)}`);
    }

    const elements = {};
    parser.ast.translate(elements);

    for (const [key, value] of Object.entries(elements)) {
      this[key] = value;
    }
  }

}

var ErrorTypes;

(function (ErrorTypes) {
  ErrorTypes["INVALID_SIGNATURE"] = "Invalid signature.";
  ErrorTypes["EXPIRED_MESSAGE"] = "Expired message.";
  ErrorTypes["MALFORMED_SESSION"] = "Malformed session.";
})(ErrorTypes || (ErrorTypes = {}));

var SignatureType;

(function (SignatureType) {
  SignatureType["PERSONAL_SIGNATURE"] = "Personal signature";
})(SignatureType || (SignatureType = {}));

class SiwxMessage {
  constructor(param) {
    this.domain = void 0;
    this.address = void 0;
    this.statement = undefined;
    this.uri = void 0;
    this.version = void 0;
    this.nonce = undefined;
    this.issuedAt = undefined;
    this.expirationTime = undefined;
    this.notBefore = undefined;
    this.requestId = undefined;
    this.chainId = void 0;
    this.resources = undefined;
    this.signature = undefined;
    this.type = void 0;

    if (typeof param === 'string') {
      const parsedMessage = new ParsedMessage(param);
      this.domain = parsedMessage.domain;
      this.address = parsedMessage.address;
      this.statement = parsedMessage.statement;
      this.uri = parsedMessage.uri;
      this.version = parsedMessage.version;
      this.nonce = parsedMessage.nonce;
      this.issuedAt = parsedMessage.issuedAt;
      this.expirationTime = parsedMessage.expirationTime;
      this.notBefore = parsedMessage.notBefore;
      this.requestId = parsedMessage.requestId;
      this.chainId = parsedMessage.chainId;
      this.resources = parsedMessage.resources;
    } else {
      Object.assign(this, param);
    }
  }

  static fromCacao(cacao) {
    const account = AccountId.parse(cacao.p.iss.replace('did:pkh:', ''));
    const siwx = new this({
      domain: cacao.p.domain,
      address: account.address,
      uri: cacao.p.aud,
      version: cacao.p.version,
      chainId: new ChainId(account.chainId).reference
    });
    if (cacao.p.statement) siwx.statement = cacao.p.statement;
    if (cacao.p.nonce) siwx.nonce = cacao.p.nonce;
    if (cacao.p.iat) siwx.issuedAt = cacao.p.iat;
    if (cacao.p.exp) siwx.expirationTime = cacao.p.exp;
    if (cacao.p.nbf) siwx.notBefore = cacao.p.nbf;
    if (cacao.p.requestId) siwx.requestId = cacao.p.requestId;
    if (cacao.p.resources) siwx.resources = cacao.p.resources;

    if (cacao.s) {
      if (cacao.s.s) siwx.signature = cacao.s.s;
      if (cacao.s.t === 'eip191') siwx.type = SignatureType.PERSONAL_SIGNATURE;
    }

    return siwx;
  }

  toMessage(chain) {
    return asString(this, chain);
  }

}
function asLegacyChainIdString(message, chainName) {
  const header = `${message.domain} wants you to sign in with your ${chainName} account:`;
  const uriField = `URI: ${message.uri}`;
  let prefix = [header, message.address].join('\n');
  const versionField = `Version: ${message.version}`;

  if (!message.nonce) {
    message.nonce = (Math.random() + 1).toString(36).substring(4);
  }

  const nonceField = `Nonce: ${message.nonce}`;
  const suffixArray = [uriField, versionField, nonceField];

  message.issuedAt = message.issuedAt ? message.issuedAt : new Date().toISOString();
  suffixArray.push(`Issued At: ${message.issuedAt}`);

  if (message.expirationTime) {
    const expiryField = `Expiration Time: ${message.expirationTime}`;
    suffixArray.push(expiryField);
  }

  if (message.notBefore) {
    suffixArray.push(`Not Before: ${message.notBefore}`);
  }

  if (message.requestId) {
    suffixArray.push(`Request ID: ${message.requestId}`);
  }

  if (message.chainId) {
    suffixArray.push(`Chain ID: ${message.chainId}`);
  }

  if (message.resources) {
    suffixArray.push([`Resources:`, ...message.resources.map(x => `- ${x}`)].join('\n'));
  }

  const suffix = suffixArray.join('\n');

  if (message.statement) {
    prefix = [prefix, message.statement].join('\n\n');
  }

  return [prefix, suffix].join('\n\n');
}
function asString(message, chainName) {
  const header = `${message.domain} wants you to sign in with your ${chainName} account:`;
  const uriField = `URI: ${message.uri}`;
  let prefix = [header, message.address].join('\n');
  const versionField = `Version: ${message.version}`;

  if (!message.nonce) {
    message.nonce = (Math.random() + 1).toString(36).substring(4);
  }

  const nonceField = `Nonce: ${message.nonce}`;
  const chainIdField = `Chain ID: ${message.chainId}`;
  const suffixArray = [uriField, versionField, chainIdField, nonceField];

  message.issuedAt = message.issuedAt ? message.issuedAt : new Date().toISOString();
  suffixArray.push(`Issued At: ${message.issuedAt}`);

  if (message.expirationTime) {
    const expiryField = `Expiration Time: ${message.expirationTime}`;
    suffixArray.push(expiryField);
  }

  if (message.notBefore) {
    suffixArray.push(`Not Before: ${message.notBefore}`);
  }

  if (message.requestId) {
    suffixArray.push(`Request ID: ${message.requestId}`);
  }

  if (message.resources && message.resources.length >= 1) {
    suffixArray.push([`Resources:`, ...message.resources.map(x => `- ${x}`)].join('\n'));
  }

  const suffix = suffixArray.join('\n');

  if (message.statement) {
    prefix = [prefix, message.statement].join('\n\n');
  }

  return [prefix, suffix].join('\n\n');
}

class SiweMessage extends SiwxMessage {
  toMessage() {
    return super.toMessage('Ethereum');
  }

  signMessage() {
    let message;

    switch (this.type) {
      case SignatureType.PERSONAL_SIGNATURE:
        {
          message = this.toMessage();
          break;
        }

      default:
        {
          message = this.toMessage();
          break;
        }
    }

    return message;
  }

}

class SiwsMessage extends SiwxMessage {
  toMessage() {
    return super.toMessage('Solana');
  }

  signMessage() {
    let message;

    switch (this.type) {
      case SignatureType.PERSONAL_SIGNATURE:
        {
          message = new TextEncoder().encode(this.toMessage());
          break;
        }

      default:
        {
          message = new TextEncoder().encode(this.toMessage());
          break;
        }
    }

    return message;
  }

}

const CLOCK_SKEW_DEFAULT_SEC = 5 * 60;
const LEGACY_CHAIN_ID_REORG_DATE = new Date('2022-09-20').valueOf();
var Cacao;

(function (Cacao) {
  function fromSiweMessage(siweMessage) {
    const cacao = {
      h: {
        t: 'eip4361'
      },
      p: {
        domain: siweMessage.domain,
        iat: siweMessage.issuedAt,
        iss: `did:pkh:eip155:${siweMessage.chainId}:${siweMessage.address}`,
        aud: siweMessage.uri,
        version: siweMessage.version,
        nonce: siweMessage.nonce
      }
    };

    if (siweMessage.signature) {
      cacao.s = {
        t: 'eip191',
        s: siweMessage.signature
      };
    }

    if (siweMessage.notBefore) {
      cacao.p.nbf = siweMessage.notBefore;
    }

    if (siweMessage.expirationTime) {
      cacao.p.exp = siweMessage.expirationTime;
    }

    if (siweMessage.statement) {
      cacao.p.statement = siweMessage.statement;
    }

    if (siweMessage.requestId) {
      cacao.p.requestId = siweMessage.requestId;
    }

    if (siweMessage.resources) {
      cacao.p.resources = siweMessage.resources;
    }

    return cacao;
  }

  const fromBlockBytes = function (bytes) {
    try {
      return Promise.resolve(Block.decode({
        bytes: bytes,
        codec: dagCbor,
        hasher: sha256
      })).then(function (block) {
        return block.value;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  Cacao.fromSiweMessage = fromSiweMessage;

  function fromSiwsMessage(siwsMessage) {
    const cacao = {
      h: {
        t: 'caip122'
      },
      p: {
        domain: siwsMessage.domain,
        iat: siwsMessage.issuedAt,
        iss: `did:pkh:solana:${siwsMessage.chainId}:${siwsMessage.address}`,
        aud: siwsMessage.uri,
        version: siwsMessage.version,
        nonce: siwsMessage.nonce
      }
    };

    if (siwsMessage.signature) {
      cacao.s = {
        t: 'solana:ed25519',
        s: siwsMessage.signature
      };
    }

    if (siwsMessage.notBefore) {
      cacao.p.nbf = siwsMessage.notBefore;
    }

    if (siwsMessage.expirationTime) {
      cacao.p.exp = siwsMessage.expirationTime;
    }

    if (siwsMessage.statement) {
      cacao.p.statement = siwsMessage.statement;
    }

    if (siwsMessage.requestId) {
      cacao.p.requestId = siwsMessage.requestId;
    }

    if (siwsMessage.resources) {
      cacao.p.resources = siwsMessage.resources;
    }

    return cacao;
  }

  Cacao.fromSiwsMessage = fromSiwsMessage;
  Cacao.fromBlockBytes = fromBlockBytes;

  function verify(cacao, options = {}) {
    var _cacao$s, _cacao$s2;

    if (((_cacao$s = cacao.s) == null ? void 0 : _cacao$s.t) === 'eip191') {
      return verifyEIP191Signature(cacao, options);
    } else if (((_cacao$s2 = cacao.s) == null ? void 0 : _cacao$s2.t) === 'solana:ed25519') {
      return verifySolanaSignature(cacao, options);
    }

    throw new Error('Unsupported CACAO signature type');
  }

  Cacao.verify = verify;

  function verifyEIP191Signature(cacao, options) {
    if (!cacao.s) {
      throw new Error(`CACAO does not have a signature`);
    }

    const atTime = options.atTime ? options.atTime.getTime() : Date.now();
    const clockSkew = (options.clockSkewSecs ?? CLOCK_SKEW_DEFAULT_SEC) * 1000;

    if (Date.parse(cacao.p.iat) > atTime + clockSkew || Date.parse(cacao.p.nbf) > atTime + clockSkew) {
      throw new Error(`CACAO is not valid yet`);
    }

    const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1000 : 0;

    if (!options.disableExpirationCheck && Date.parse(cacao.p.exp) + phaseOutMS + clockSkew < atTime) {
      throw new Error(`CACAO has expired`);
    }

    const recoveredAddress = verifyMessage(SiweMessage.fromCacao(cacao).toMessage(), cacao.s.s).toLowerCase();
    const recoveredAddresses = [recoveredAddress];

    if (Date.parse(cacao.p.iat) <= LEGACY_CHAIN_ID_REORG_DATE) {
      const legacyChainIdRecoveredAddress = verifyMessage(asLegacyChainIdString(SiweMessage.fromCacao(cacao), 'Ethereum'), cacao.s.s).toLowerCase();
      recoveredAddresses.push(legacyChainIdRecoveredAddress);
    }

    const issuerAddress = AccountId.parse(cacao.p.iss.replace('did:pkh:', '')).address.toLowerCase();

    if (!recoveredAddresses.includes(issuerAddress)) {
      throw new Error(`Signature does not belong to issuer`);
    }
  }

  Cacao.verifyEIP191Signature = verifyEIP191Signature;
})(Cacao || (Cacao = {}));

function verifySolanaSignature(cacao, options) {
  if (!cacao.s) {
    throw new Error(`CACAO does not have a signature`);
  }

  const atTime = options.atTime ? options.atTime.getTime() : Date.now();

  if (Date.parse(cacao.p.iat) > atTime || Date.parse(cacao.p.nbf) > atTime) {
    throw new Error(`CACAO is not valid yet`);
  }

  const phaseOutMS = options.revocationPhaseOutSecs ? options.revocationPhaseOutSecs * 1000 : 0;

  if (!options.disableExpirationCheck && Date.parse(cacao.p.exp) + phaseOutMS < atTime) {
    throw new Error(`CACAO has expired`);
  }

  const msg = SiwsMessage.fromCacao(cacao);
  const sig = cacao.s.s;
  const messageU8 = msg.signMessage();
  const sigU8 = fromString(sig, 'base58btc');
  const issAddress = AccountId.parse(cacao.p.iss.replace('did:pkh:', '')).address;
  const pubKeyU8 = fromString(issAddress, 'base58btc');

  if (!verify(pubKeyU8, messageU8, sigU8)) {
    throw new Error(`Signature does not belong to issuer`);
  }
}
var CacaoBlock;

(function (CacaoBlock) {
  function fromCacao(cacao) {
    return Block.encode({
      value: cacao,
      codec: dagCbor,
      hasher: sha256
    });
  }

  CacaoBlock.fromCacao = fromCacao;
})(CacaoBlock || (CacaoBlock = {}));

export { Cacao, CacaoBlock, ErrorTypes, LEGACY_CHAIN_ID_REORG_DATE, SignatureType, SiweMessage, SiwsMessage, SiwxMessage, asLegacyChainIdString, asString, verifySolanaSignature };
//# sourceMappingURL=index.mjs.map
